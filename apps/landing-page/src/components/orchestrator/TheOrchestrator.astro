---
import NeuralCore from "./NeuralCore.astro";
import ProfileOrb from "./ProfileOrb.astro";

const accountCount = 6;
---

<section id="orchestrator" class="relative z-30 w-full h-screen bg-background overflow-hidden selection:bg-primary selection:text-primary-foreground">
  <!-- Background Distortion (Subtle) -->
  <div class="absolute inset-0 bg-[radial-gradient(circle_at_center,hsl(var(--primary)/0.03)_0%,transparent_70%)] pointer-events-none"></div>

  <!-- SVG Overlay for Tendrils -->
  <svg id="orchestrator-tendrils" class="absolute inset-0 w-full h-full pointer-events-none z-25 overflow-visible">
    <defs>
      <filter id="glow">
        <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
        <feMerge>
          <feMergeNode in="coloredBlur"/>
          <feMergeNode in="SourceGraphic"/>
        </feMerge>
      </filter>
    </defs>
  </svg>

  <!-- Sticky/Pinned Content -->
  <div class="h-full w-full flex flex-col items-center justify-center relative">
    
    <!-- Title Area (Sequential Act 1) -->
    <div class="absolute top-[15%] text-center z-20 pointer-events-none px-6">
      <h2 id="orchestrator-title" class="text-4xl md:text-7xl font-black tracking-tighter opacity-0 translate-y-10">
        ONE BRAIN. <br/> <span class="text-primary">INFINITE ACCOUNTS.</span>
      </h2>
      <p id="orchestrator-desc" class="mt-4 text-muted-foreground text-lg max-w-lg mx-auto opacity-0">
        Scale your influence across multiple threads and profiles simultaneously.
      </p>
    </div>

    <!-- The Neural Core -->
    <div id="orchestrator-core-wrapper" class="relative z-20 scale-50 opacity-0 will-change-transform">
      <NeuralCore />
    </div>

    <!-- Profile Orbs Container -->
    <div id="orbs-container" class="absolute inset-0 flex items-center justify-center pointer-events-none">
      {Array.from({ length: accountCount }).map((_, i) => (
        <ProfileOrb index={i} class="will-change-transform" />
      ))}
    </div>

    <!-- Final CTA/Sync Info -->
    <div id="orchestrator-sync-msg" class="absolute bottom-[10%] text-center z-20 px-6 opacity-0 translate-y-10">
      <div class="inline-flex items-center gap-3 px-6 py-2 rounded-full border border-primary/20 bg-primary/5 backdrop-blur-sm">
        <div class="w-2 h-2 rounded-full bg-primary animate-ping"></div>
        <span class="text-sm font-bold tracking-widest text-primary uppercase">All Systems Synchronized</span>
      </div>
    </div>

  </div>
</section>

<script>
  import gsap from 'gsap';
  import { ScrollTrigger } from 'gsap/ScrollTrigger';

  gsap.registerPlugin(ScrollTrigger);

  const initOrchestrator = () => {
    const section = document.getElementById('orchestrator');
    if (!section) return;

    const core = document.getElementById('orchestrator-core-wrapper');
    const orbs = document.querySelectorAll('.profile-orb');
    const tendrilSvg = document.getElementById('orchestrator-tendrils');
    const accountCount = orbs.length;

    // Stable path calculation
    const updatePath = (path, orb) => {
      const coreRect = core?.getBoundingClientRect();
      const orbRect = orb.getBoundingClientRect();
      const svgRect = tendrilSvg?.getBoundingClientRect();
    
      if (coreRect && orbRect && svgRect) {
        // Start from center of core
        const startX = coreRect.left + coreRect.width / 2 - svgRect.left;
        const startY = coreRect.top + coreRect.height / 2 - svgRect.top;
        
        // Target center of orb
        const endX = orbRect.left + orbRect.width / 2 - svgRect.left;
        const endY = orbRect.top + orbRect.height / 2 - svgRect.top;
    
        const angle = Math.atan2(endY - startY, endX - startX);
        const dist = Math.sqrt((endX - startX)**2 + (endY - startY)**2);
        
        // Dynamic curvature based on distance
        const curveIntensity = Math.min(dist * 0.2, 50);
        
        // Use a cubic bezier for a more "organic" feel if needed, but quadratic is fine for now
        // Offset control point to create the curve
        const cpX = (startX + endX) / 2 + Math.cos(angle - Math.PI / 2) * curveIntensity;
        const cpY = (startY + endY) / 2 + Math.sin(angle - Math.PI / 2) * curveIntensity;
    
        path.setAttribute("d", `M${startX},${startY} Q${cpX},${cpY} ${endX},${endY}`);
      }
    };

    const tl = gsap.timeline({
      scrollTrigger: {
        trigger: section,
        start: "top top",
        end: "+=300%",
        scrub: 1,
        pin: true,
        anticipatePin: 1,
      }
    });

    // --- STAGE 1: The Hook (Text Only) ---
    tl.to("#orchestrator-title", { opacity: 1, y: 0, duration: 1.5 })
      .to("#orchestrator-desc", { opacity: 1, duration: 1 }, "-=0.5")
      .to({}, { duration: 1 }); 

    // --- STAGE 2: The Transition (Clear the Stage) ---
    tl.to(["#orchestrator-title", "#orchestrator-desc"], { 
        y: -150, 
        opacity: 0, 
        duration: 1.5, 
        ease: "power2.in" 
      })
      .to(core, { 
        opacity: 1, 
        scale: 1, 
        y: 0, 
        duration: 2, 
        ease: "back.out(1.5)" 
      }, "-=0.5");

    // --- STAGE 3: Orb Deployment ---
    tl.to(orbs, {
      opacity: 1,
      scale: 1,
      duration: 1.5,
      stagger: 0.1,
      ease: "back.out(1.2)",
      onUpdate: function() {
        orbs.forEach((orb, i) => {
          const radius = window.innerWidth < 768 ? 100 : 250;
          // Position orbs based on index: 0 is top, increments go clockwise
          const angle = (i / accountCount) * Math.PI * 2 - Math.PI / 2;
          const x = Math.cos(angle) * radius;
          const y = Math.sin(angle) * radius;
          gsap.set(orb, { x, y });
        });
      }
    }, "-=1");

    // --- STAGE 4: Sequential Tendril Connectivity (Top -> Top-Left -> Top-Right -> Bottom-Left -> Bottom-Right -> Bottom) ---
    const tendrilGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
    tendrilSvg?.appendChild(tendrilGroup);

    // Specific order for Top-to-Bottom, Left-to-Right flow
    // 0: Top, 5: Top-Left, 1: Top-Right, 4: Bottom-Left, 2: Bottom-Right, 3: Bottom
    const sequence = [0, 5, 1, 4, 2, 3];

    sequence.forEach((index) => {
      const orb = orbs[index];
      if (!orb) return;

      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute("class", "tendril-path");
      path.setAttribute("stroke", "hsl(var(--primary) / 0.6)");
      path.setAttribute("fill", "none");
      path.setAttribute("stroke-width", "2");
      path.setAttribute("filter", "url(#glow)");
      path.setAttribute("stroke-linecap", "round");
      tendrilGroup.appendChild(path);

      // Initialize path position
      updatePath(path, orb);
      const totalLength = 1500; // Safe upper bound for initial state
      path.style.strokeDasharray = `${totalLength}`;
      path.style.strokeDashoffset = `${totalLength}`;

      // 1. Tendril grows from core to orb
      tl.to(path, { 
          strokeDashoffset: 0, 
          duration: 1.2,
          ease: "power2.inOut",
          onUpdate: () => {
             updatePath(path, orb);
             // Readjust dasharray to actual length for perfect termination
             const actualLength = path.getTotalLength();
             path.style.strokeDasharray = `${actualLength}`;
          },
        }, ">-0.4") // Smooth overlap with previous connection
      // 2. Handshake: Visual Feedback exactly when path reaches orb
      .to(orb.querySelector('.synced-bg'), { opacity: 1, duration: 0.6 }, "-=0.2")
      .to(orb.querySelector('.synced-glow'), { opacity: 1, scale: 1.4, duration: 0.8 }, "<")
      .to(orb.querySelector('.profile-ring'), { 
        borderColor: 'rgb(34 197 94)', 
        boxShadow: '0 0 30px rgba(34, 197, 94, 0.6)',
        duration: 0.5 
      }, "<")
      .to(orb.querySelector('.profile-icon'), { color: 'rgb(34 197 94)', duration: 0.5 }, "<")
      .to(orb.querySelector('.data-badge'), { opacity: 1, y: 0, scale: 1, duration: 0.5 }, "-=0.3")
      // 3. Pulse effect on core to show power transfer
      .to(core, { scale: 1.08, duration: 0.2, yoyo: true, repeat: 1, ease: "power2.out" }, "<");
    });

    // Final Sync Message
    tl.to("#orchestrator-sync-msg", { opacity: 1, y: 0, duration: 1.5 });
  };

  // Run on load
  document.addEventListener('astro:page-load', initOrchestrator);
  // Fallback for non-transition loads
  initOrchestrator();
</script>

<style>
  .tendril-path {
    /* Relying on SVG filter for better cross-browser SVG rendering */
    opacity: 0.8;
  }
</style>
