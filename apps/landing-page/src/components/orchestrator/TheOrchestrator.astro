---
import NeuralCore from "./NeuralCore.astro";
import ProfileOrb from "./ProfileOrb.astro";

const accountCount = 6;
---

<section id="orchestrator" class="relative z-30 w-full h-screen bg-background overflow-hidden selection:bg-primary selection:text-primary-foreground">
  <!-- Background Distortion (Subtle) -->
  <div class="absolute inset-0 bg-[radial-gradient(circle_at_center,hsl(var(--primary)/0.03)_0%,transparent_70%)] pointer-events-none"></div>

  <!-- SVG Overlay for Tendrils -->
  <svg id="orchestrator-tendrils" class="absolute inset-0 w-full h-full pointer-events-none z-10">
    <defs>
      <filter id="glow">
        <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
        <feMerge>
          <feMergeNode in="coloredBlur"/>
          <feMergeNode in="SourceGraphic"/>
        </feMerge>
      </filter>
    </defs>
  </svg>

  <!-- Sticky/Pinned Content -->
  <div class="h-full w-full flex flex-col items-center justify-center relative">
    
    <!-- Title Area (Sequential Act 1) -->
    <div class="absolute top-[15%] text-center z-20 pointer-events-none px-6">
      <h2 id="orchestrator-title" class="text-4xl md:text-7xl font-black tracking-tighter opacity-0 translate-y-10">
        ONE BRAIN. <br/> <span class="text-primary">INFINITE ACCOUNTS.</span>
      </h2>
      <p id="orchestrator-desc" class="mt-4 text-muted-foreground text-lg max-w-lg mx-auto opacity-0">
        Scale your influence across multiple threads and profiles simultaneously.
      </p>
    </div>

    <!-- The Neural Core -->
    <div id="orchestrator-core-wrapper" class="relative z-20 scale-50 opacity-0 will-change-transform">
      <NeuralCore />
    </div>

    <!-- Profile Orbs Container -->
    <div id="orbs-container" class="absolute inset-0 flex items-center justify-center pointer-events-none">
      {Array.from({ length: accountCount }).map((_, i) => (
        <ProfileOrb index={i} class="will-change-transform" />
      ))}
    </div>

    <!-- Final CTA/Sync Info -->
    <div id="orchestrator-sync-msg" class="absolute bottom-[10%] text-center z-20 px-6 opacity-0 translate-y-10">
      <div class="inline-flex items-center gap-3 px-6 py-2 rounded-full border border-primary/20 bg-primary/5 backdrop-blur-sm">
        <div class="w-2 h-2 rounded-full bg-primary animate-ping"></div>
        <span class="text-sm font-bold tracking-widest text-primary uppercase">All Systems Synchronized</span>
      </div>
    </div>

  </div>
</section>

<script>
  import gsap from 'gsap';
  import { ScrollTrigger } from 'gsap/ScrollTrigger';

  gsap.registerPlugin(ScrollTrigger);

  const initOrchestrator = () => {
    const section = document.getElementById('orchestrator');
    if (!section) return;

    const core = document.getElementById('orchestrator-core-wrapper');
    const orbs = document.querySelectorAll('.profile-orb');
    const tendrilSvg = document.getElementById('orchestrator-tendrils');
    const accountCount = orbs.length;

    // Stable path calculation (No random in loop)
    const updatePath = (path, orb) => {
      const coreRect = core?.getBoundingClientRect();
      const orbRect = orb.getBoundingClientRect();
      const svgRect = tendrilSvg?.getBoundingClientRect();

      if (coreRect && orbRect && svgRect) {
        const startX = coreRect.left + coreRect.width / 2 - svgRect.left;
        const startY = coreRect.top + coreRect.height / 2 - svgRect.top;
        const endX = orbRect.left + orbRect.width / 2 - svgRect.left;
        const endY = orbRect.top + orbRect.height / 2 - svgRect.top;

        // Calculate angle based on orb position relative to core
        const angle = Math.atan2(endY - startY, endX - startX);
        
        // Consistent outward curvature: offset perpendicular to the main path vector
        const curveIntensity = 40;
        const cpX = (startX + endX) / 2 + Math.cos(angle - Math.PI / 2) * curveIntensity;
        const cpY = (startY + endY) / 2 + Math.sin(angle - Math.PI / 2) * curveIntensity;

        path.setAttribute("d", `M${startX},${startY} Q${cpX},${cpY} ${endX},${endY}`);
      }
    };

    const tl = gsap.timeline({
      scrollTrigger: {
        trigger: section,
        start: "top top",
        end: "+=300%",
        scrub: 1,
        pin: true,
        anticipatePin: 1,
      }
    });

    // --- STAGE 1: The Hook (Text Only) ---
    tl.to("#orchestrator-title", { opacity: 1, y: 0, duration: 1.5 })
      .to("#orchestrator-desc", { opacity: 1, duration: 1 }, "-=0.5")
      .to({}, { duration: 1 }); 

    // --- STAGE 2: The Transition (Clear the Stage) ---
    tl.to(["#orchestrator-title", "#orchestrator-desc"], { 
        y: -150, 
        opacity: 0, 
        duration: 1.5, 
        ease: "power2.in" 
      })
      .to(core, { 
        opacity: 1, 
        scale: 1, 
        y: 0, 
        duration: 2, 
        ease: "back.out(1.5)" 
      }, "-=0.5");

    // --- STAGE 3: Orb Deployment ---
    tl.to(orbs, {
      opacity: 1,
      scale: 1,
      duration: 1.5,
      stagger: 0.1,
      ease: "back.out(1.2)",
      onUpdate: function() {
        orbs.forEach((orb, i) => {
          const radius = window.innerWidth < 768 ? 100 : 250;
          // Position orbs based on index: 0 is top, increments go clockwise
          const angle = (i / accountCount) * Math.PI * 2 - Math.PI / 2;
          const x = Math.cos(angle) * radius;
          const y = Math.sin(angle) * radius;
          gsap.set(orb, { x, y });
        });
      }
    }, "-=1");

    // --- STAGE 4: Sequential Tendril Connectivity (Top -> Right / Clockwise) ---
    const tendrilGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
    tendrilSvg?.appendChild(tendrilGroup);

    // Ensure we iterate in the correct visual order (0 is top, indices increment clockwise)
    orbs.forEach((orb, i) => {
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute("class", "tendril-path");
      path.setAttribute("stroke", "hsl(var(--primary) / 0.4)");
      path.setAttribute("fill", "none");
      path.setAttribute("stroke-width", "2");
      path.setAttribute("filter", "url(#glow)");
      tendrilGroup.appendChild(path);

      // 1. Tendril grows from core to orb
      tl.fromTo(path, 
        { strokeDasharray: 1000, strokeDashoffset: 1000 },
        { 
          strokeDashoffset: 0, 
          duration: 1.2,
          ease: "power1.inOut",
          onUpdate: () => updatePath(path, orb),
        }
      )
      // 2. Handshake: Visual Feedback exactly when path reaches orb
      .to(orb.querySelector('.synced-bg'), { opacity: 1, duration: 0.4 }, "-=0.2")
      .to(orb.querySelector('.synced-glow'), { opacity: 1, scale: 1.2, duration: 0.6 }, "<")
      .to(orb.querySelector('.profile-ring'), { 
        borderColor: 'rgb(34 197 94)', 
        boxShadow: '0 0 20px rgba(34, 197, 94, 0.4)',
        duration: 0.4 
      }, "<")
      .to(orb.querySelector('.profile-icon'), { color: 'rgb(34 197 94)', duration: 0.4 }, "<")
      .to(orb.querySelector('.data-badge'), { opacity: 1, y: 0, scale: 1, duration: 0.4 }, "-=0.2")
      // 3. Pulse effect on core to show power transfer
      .to(core, { scale: 1.05, duration: 0.2, yoyo: true, repeat: 1, ease: "power2.out" }, "<")
      // Add a tiny bit of overlap to the next connection for a "flowing" feel
      .addLabel(`sync-${i}`);
    });

    // Final Sync Message
    tl.to("#orchestrator-sync-msg", { opacity: 1, y: 0, duration: 1.5 });
  };

  // Run on load
  document.addEventListener('astro:page-load', initOrchestrator);
  // Fallback for non-transition loads
  initOrchestrator();
</script>

<style>
  .tendril-path {
    filter: drop-shadow(0 0 5px hsl(var(--primary) / 0.5));
  }
</style>
